{"meta":{"title":"Marin's Blog","subtitle":"不学习你和咸鱼有什么区别","description":"marin的个人学习博客，分享知识，享受快乐。","author":"Marin","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-03-21T15:17:13.000Z","updated":"2018-03-21T15:18:15.747Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"layout: categories comments: false"},{"title":"tags","date":"2018-03-21T15:17:13.000Z","updated":"2018-03-21T15:18:42.764Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"layout: tags comments: false"}],"posts":[{"title":"Java实现每日登陆增加积分功能","slug":"Java实现每日登陆增加积分功能","date":"2018-04-09T07:04:52.629Z","updated":"2018-04-09T08:18:08.968Z","comments":true,"path":"2018/04/09/Java实现每日登陆增加积分功能/","link":"","permalink":"http://yoursite.com/2018/04/09/Java实现每日登陆增加积分功能/","excerpt":"","text":"思路数据库中增加最后登陆时间的字段（last_login_time），通过这个值与系统当前时间进行比较。 看到这应该明白了，只要登陆成功的时候执行判断这两个时间是否同一天就可以实现这个功能，如果是同一天我们就给他增加积分，不是我们就不加。 ps：要注意了，登陆成功的时候要更新最后一次登陆时间的，不然登陆一次就会加一次积分。 代码这个方法最关键的就是判断同一天这个功能了，我们可以利用commons-lang3包中的isSameDay方法。 org.apache.commons.lang3.time.DateUtils.isSameDay(Date date1, Date date2) 我们来看isSameDay方法源代码 12345678910111213141516171819public static boolean isSameDay(Date date1, Date date2) &#123; if(date1 != null &amp;&amp; date2 != null) &#123; Calendar cal1 = Calendar.getInstance(); cal1.setTime(date1); Calendar cal2 = Calendar.getInstance(); cal2.setTime(date2); return isSameDay(cal1, cal2); &#125; else &#123; throw new IllegalArgumentException(\"The date must not be null\"); &#125; &#125; public static boolean isSameDay(Calendar cal1, Calendar cal2) &#123; if(cal1 != null &amp;&amp; cal2 != null) &#123; return cal1.get(0) == cal2.get(0) &amp;&amp; cal1.get(1) == cal2.get(1) &amp;&amp; cal1.get(6) == cal2.get(6); &#125; else &#123; throw new IllegalArgumentException(\"The date must not be null\"); &#125; &#125; 上面方法中的0、1、6的含义如下： 123456789101112131415public final static int ERA = 0; /** * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the * year. This is a calendar-specific value; see subclass documentation. */ public final static int YEAR = 1; /** * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the day * number within the current year. The first day of the year has value 1. */ public final static int DAY_OF_YEAR = 6; ps:利用是否是同一ERA（翻译成：世纪）且同一年的第N天来判断的。 补充在贴一个如何获得明天零点的代码： 1234567891011121314151617public class TestCalendar &#123; public static void main(String[] args) &#123; Date currentEndDate = new Date(); Calendar cal = Calendar.getInstance(); cal.setTime(currentEndDate); cal.add(Calendar.DATE, 1); cal.set(Calendar.AM_PM, 0); cal.set(Calendar.HOUR, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); Date nextDate = cal.getTime(); System.out.println(nextDate); &#125; &#125;","categories":[],"tags":[]},{"title":"Java IO流","slug":"JavaIO","date":"2018-03-26T07:19:01.101Z","updated":"2018-03-29T06:26:05.288Z","comments":true,"path":"2018/03/26/JavaIO/","link":"","permalink":"http://yoursite.com/2018/03/26/JavaIO/","excerpt":"","text":"概述Java中对于数据的操作都是通过流来实现的，而所有操作流的对象都在IO包中。所谓IO流其实是指，Input和Output流。首先明白字节(Byte)和字符(Character)的大小 1 byte = 8 bit 1 char = 2 byte = 16 bit(Java默认UTF-16编码) 详细请看下面关系图： 20160308131106443 File对象File对象用来描述操作系统中文件对象，可以是单个文件或是一个文件目录 1.创建File对象1File file = new File(\"C:\" + File.separator+ \"1.txt\"); ps: File.separator是File封装的静态字段，表示路径分隔符，因为在Windows和Linux系统分隔符不一样，所有如果用”/”在不同环境下就会报错，所以采用File.separator来表示分隔符，这是一个良好的代码编写习惯。 2.File对象常用APIFile常见API没多少，如果不知道的可以自行百度一波，都是很简单的🤣。 字节流1.概述字节流一般用来操作媒体文件（媒体文件也是以字节存储的） InputStream:所有字节输入流的父类，具有基础的读方法int read()–读取一个字节，以int形式返回,如果返回值为-1，说明读到了文件的末尾int read(byte[] b)–尝试最多读取给定byte数组的长度个字节并存入该数组，返回值为实际读取到的自己量 OutPutStream:是所有字节输出流的父类，具有基础的写出方法void write(int d)–写出一个字节void write(byte[] d)–将给定字节数组中的所有字节全部写出void write(byte[] d,int off,int len)–写出字节数组中从下标off开始的连续length个字节 2.练习个人认为对于IO流的理解还是得靠代码，读懂代码才是王道。Test:复制一张图片F:\\java_Demo\\1.bmp到F:\\java_Demo\\2.bmp 12345678910111213141516171819202122232425262728293031323334353637class CopyPic &#123; public static void main(String[] args)&#123; copyBmp(); System.out.println(\"复制完成\"); &#125; public static void copyBmp() &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; //写入流关联文件 fis = new FileInputStream(\"F:\"+File.separator+\"java_Demo\"+File.separator+\"1.bmp\"); //读取流关联文件 fos = new FileInputStream(\"F:\"+File.separator+\"java_Demo\"+File.separator+\"2.bmp\"); byte[] copy = new byte[1024]; int len = 0; while((len=fis.read(copy))!=-1) &#123; fos.write(copy,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(\"复制文件异常\"); &#125; finally &#123; try &#123; if(fis!=null) fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(\"读取流\"); &#125; &#125; &#125; &#125; 3.字节流缓冲区BufferedInputStream,BufferedOutputStream缓冲流的内部维护了一个缓冲区，每当向输入输出流读写数据时，会先将数据保存在缓冲区，当缓冲区满了以后，将数据一次性读写出来，这样可以减少IO操作的次数，从而提高读写效率 Demo:使用缓冲输出流和缓冲输入流实现文件的复制 12345678910111213141516171819202122232425262728293031public class SummaryBISAndBOS &#123; public static void main(String[] args)&#123; /** * 1.先将文件中的内容读入到缓冲输入流中 * 2.将输入流中的数据通过缓冲输出流写入到目标文件中 * 3.关闭输入流和输出流 */ try &#123; long begin=System.currentTimeMillis(); FileInputStream fis=new FileInputStream(\"BISDemo.txt\"); BufferedInputStream bis=new BufferedInputStream(fis); FileOutputStream fos=new FileOutputStream(\"BOSDemo.txt\"); BufferedOutputStream bos=new BufferedOutputStream(fos); int size=0; byte[] buffer=new byte[10240]; while((size=bis.read(buffer))!=-1)&#123; bos.write(buffer, 0, size); &#125; //刷新此缓冲的输出流，保证数据全部都能写出 bos.flush(); bis.close(); bos.close(); long end=System.currentTimeMillis(); System.out.println(\"使用缓冲输出流和缓冲输入流实现文件的复制完毕！耗时：\"+(end-begin)+\"毫秒\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字符流字符流以char为单位对数据进行读写，一次处理一个unicode，字符流的底层是基本的字节流。Reader是字符输入流的父类 int read() –读取一个字符，这个int返回值可以转换为其对应的char型字符，如果返回-1，说明已经到达末尾int read(char[] chars) –从流中读取一个字符数组的length个字符并存入该数组，返回值为实际读取到的字符量 Writer是字符输出流的父类void write(int c) –写出一个字符void write(char[] chs) –将给定字符数组中的所有字符写出void write(String str) –将给定的字符串写出void write(char[] chs,int off,int len) –将给定字符数组中从off开始连续len个字符写出 练习Test: 用字符流拷贝文件 12345678910111213141516171819202122232425262728293031323334353637383940class CopyText &#123; public static void main(String[] args) throws IOException &#123; sop(\"请输入要拷贝的文件的路径:\"); Scanner in = new Scanner(System.in); String source = in.next(); sop(\"请输入需要拷贝到那个位置的路径以及生成的文件名:\"); String destination = in.next(); in.close(); CopyTextDemo(source,destination); &#125; /*****************文件Copy*********************/ private static void CopyTextDemo(String source,String destination) &#123; try &#123; FileWriter fw = new FileWriter(destination); FileReader fr = new FileReader(source); char [] buf = new char[1024]; //将Denmo中的文件读取到buf数组中。 int num = 0; while((num = fr.read(buf))!=-1) &#123; //String(char[] value , int offest,int count) 分配一个新的String,包含从offest开始的count个字符 fw.write(new String(buf,0,num)); &#125; fr.close(); fw.close(); &#125; catch (IOException e) &#123; sop(e.toString()); &#125; &#125; /**********************Println************************/ private static void sop(Object obj) &#123; System.out.println(obj); &#125; &#125; 字符流缓冲区BufferedReader，BufferedWriter 作用及实现和字节流缓冲区大同小异。 Test: BufferedReader示例 1234567891011121314151617181920class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; //创建一个字符读取流流对象，和文件关联 FileReader rw = new FileReader(\"buf.txt\"); //只要将需要被提高效率的流作为参数传递给缓冲区的构造函数即可 BufferedReader brw = new BufferedReader(rw); for(;;) &#123; String s = brw.readLine(); if(s==null) break; System.out.println(s); &#125; brw.close();//关闭输入流对象 &#125; &#125; Test: BufferedWriter示例 1234567891011121314151617181920212223242526272829class BufferedWriterDemo &#123; public static void main(String[] args) throws IOException &#123; //创建一个字符写入流对象 FileWriter fw = new FileWriter(\"buf.txt\"); //为了提高字符写入效率，加入了缓冲技术。 //只要将需要被提高效率的流作为参数传递给缓冲区的构造函数即可 BufferedWriter bfw = new BufferedWriter(fw); //bfw.write(\"abc\\r\\nde\"); //bfw.newLine(); 这行代码等价于bfw.write(\"\\r\\n\"),相当于一个跨平台的换行符 //用到缓冲区就必须要刷新 for(int x = 1; x &lt; 5; x++) &#123; bfw.write(\"abc\"); bfw.newLine(); //java提供了一个跨平台的换行符newLine(); bfw.flush(); &#125; bfw.flush(); //刷新缓冲区 bfw.close(); //关闭缓冲区，但是必须要先刷新 //注意，关闭缓冲区就是在关闭缓冲中的流对象 fw.close(); //关闭输入流对象 &#125; &#125; NIONIO 非阻塞IO(面向缓冲)1.NIO弥补了原来I/O的不足之处，在IO操作中提供了高速度的，面向块的IO操作2.NIO中数据的打包和传递方式是以块为单位的，普通IO中以流为操作单位 NIO的2个重要特性(1)通道通道(Channel)是对于普通I/O中流的模拟，从任何地方读数据，或将数据写到任何地方都必须通过一个Channel对象 (2)缓冲区缓冲区Buffer实质上是一个容器对象，发送给一个通道的所有对象都必须首先放到缓冲区中；同样，从一个通道中读取数据时也需要先读取到缓冲区中。在NIO中，所有数据都是用缓冲区进行处理的。 ps:NIO效率无疑是要大大的高于IO操作的，但是实现过程要比IO复杂的多，可自行百度学习。 总结复习了一下以前学习的IO知识，写的不是很完善，因为写博客很花时间，我现在每天很忙😂，继续努力吧。","categories":[],"tags":[]},{"title":"仅以这篇博客记录我未来的编程生活","slug":"firstBlog","date":"2018-03-25T13:57:42.266Z","updated":"2018-03-25T14:17:36.885Z","comments":true,"path":"2018/03/25/firstBlog/","link":"","permalink":"http://yoursite.com/2018/03/25/firstBlog/","excerpt":"","text":"知识是一个不断积累的过程2015年开始进入大学接触编程先是学了C，然后是C#，现在主要在使用Java进行开发，还想学习Python。回想起之前的编程学习之路感觉自己学的多，忘记的更多😂，现在我想把我学习的知识记录下来，方便自己以后翻看。 123456#include&lt;stdio.h&gt;int main()&#123;printf(\"hello world!\\n\");&#125;","categories":[],"tags":[]}]}